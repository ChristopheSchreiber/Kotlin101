= Kotlin 101 for Java developers

== Who am I ?

Christophe SCHREIBER
Java developer since 2005

Member of Softeam's Java Startech :logo:

twitter_logo @Schreiber_Chris

== What is Kotlin

Kotlin is an opensource language developed by Jetbrains, running on the JVM.

Kotlin mixes elements from object oriented and functional programming.

Kotlin is meant to be:

 * Pragmatic
 * Concise
 * Safe
 * Interoperable

== Why is everybody talking about Kotlin ?
 * Because of Java 9 ? :troll:
 * Because of its support in Android
 * Because it's good !
 
== Saying Hello World in Kotlin
....
println("Hello World")
....

Kotlin code doesn't have to be stored in a class.

== Defining a function in Kotlin
....
fun sayHello() : Unit { println("Hello World") }
....
or
....
fun sayHello() = println("Hello World")
....

== Defining variables
Kotlin's type inference lets you omit the actual type of variables if the compiler can infer it
....
val myInteger : Int = 1
....
can be simplified to
....
val myInteger = 1
....

== Can my variable change ?
Kotlin enforces you to specify if variables are final or not. 
....
val immutable = 1
var mutable = 2
println(mutable)
....
>> 2
....
mutable = 3
println(mutable)
....
>> 3
....
immutable = 4
....
>> error (TODO)

== Avoiding overloaded methods

Kotlin offers default parameter values, so that you don't need to overload methods when you need an extra parameter.
....
fun sayHello(val name : String, val message = "") = println("Hello ${name} ${message}")

sayHello("World")
....
>> Hello World
....
sayHello("World", ", Kotlin is great")
....
>> Hello World, Kotlin is great

== String templates are awesome
....
fun sayHello(name : String) = println("Hello ${name}")
sayHello("Softeam")
....
>> Hello Softeam

String templates can contain actual code
....
fun shoutHello(name : String) = println("Hello ${name.toUpperCase()} !")
shoutHello("Softeam")
....
>> Hello SOFTEAM !

== Avoiding the billion dollars mistake

Kotlin ensures that most cases of null references are detected by the compiler

By default, all references are non nullable
....
val name = null
....
>> error (TODO)

== Usage of nullable references

Kotlin uses the ? character after the type definition to declare that a reference is nullable
....
val name : String? = null
....

When using nullable types, the compiler forces you to check for null references
....
val name : String? = functionThatMayReturnNullStringReference()
println(name.length)
....
>> error (TODO)
....
if (name != null) {
println(name.length)
....
Kotlin defines a shorter way to check null reference :
....
println(name?.length)
....
And the Elvis operator allows usage of a default value otherwise :
....
println(name?.length ?: 0)
....

== Safe casts
When you check if an instance is of a given type, Kotlin automatically converts to the correct type in case of success, avoiding a redundant cast.
....
val value : Any = methodReturningAnyType()
if (value is String) {
	println(value.toUpperCase()
}
....

You can also directly cast using the as operator and specify a default value if the cast fails
....
val value : Any = methodReturningAnyType()
val stringValue : String? = value.as? String ?: null
println(stringValue?.toUpperCase)
....

== Data classes without boilerplate code

Kotlin allows defining data classes very simply

....
data class Person(val firstName : String, val lastName : String)
....

Constructors, getters, setters (if attributes are mutable), equals, hashCode and copy methods are generated by the compiler.
....
val me = Person("Christophe", "Schreiber")
println(me.firstName)
....
>> Christophe
...

== Using lambdas

Kotlin supports lambda expressions, with a syntax similar to Java 8
....
val myList = listOf(1, 2, 3, 4, 5)
val evenNumbers = myList.filter({value : Int -> value % 2 == 0})
....
You can simplify this line of code by ommiting parentheses and using type inference :
....
val evenNumbers = myList.filter {value -> value % 2 == 0}
....

And you can simplify it even further since it has only one parameter :
....
val evenNumbers = myList.filter {it % 2 == 0}
....

Contrarily to Java, there is no specific type for functions, they are just defined by their signature
For instance, if you want to apply a transformation to a String then print it in Java :
....
public void transformAndPrint(String message, Function<String, String> transform) {
   System.out.println(transform.apply(message));
}
....
The equivalent Kotlin method would be :
....
fun transformAndPrint(message : String, transform : (String) -> String) = println(transform(message))
....

== Extension functions
In Kotlin, you can add features to existing classes using the extension function mechanism :
....
fun String.addBar() = this + "bar"
println("foo".addBar())
....
>> foobar
The Kotlin standard library makes heavy use of extension functions over JDK classes.

== Don't forget about OOP

== The magic switch : when

== Conventions

== And many more !

 * Lazy initialisation
 * Easy delegation
 * Infix methods
 * Domain specific language
 * ...